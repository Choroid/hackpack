\section{Bloom Filter}
\index{Bloom filter}

A Bloom filter is a probabalistic data structure that, like a set, can keep track of elements that have been seen before.
It has the added advantage of not needing to retain the data after it has been added to the filter, thus, it is more conscientous of memory usage.
It works by utilizing a bit array of $m$ bits and $k$ hash functions.
The filter can return false positives, but will \textit{never} return false negatives.
Also, with the filter alone, once a member has been added to the set, it is not possible to remove it.
This can be worked around by implementing some form of counting.

To add data to the filter, simply feed it to the $k$ hash functions, mapping it to $k$ indices in the bit array and set the bits at the $k$ indices to 1.
To test whether some data has passed through the filter, feed it to the hash functions to compute $k$ indices.
Check the values at these positions.
If a 0 is encountered, it can be immediately determined that the specified data did not pass through the filter.
If, after checking all $k$ positions in the bit array, no 0s are encountered, then the data \textbf{possibly} passed through the filter.

To illustrate  with an example, suppose that we have a Bloom filter for a set of strings with $m = 16$ bits, and we have designed $k = 3$ hash functions to map the given strings to an integer in a range of 16 values.
Let's add 'Clemson ACM' to the the filter.
After feeding the string to the three hash functions, we get three different indices to mark: 0, 7, and 8.
Also, suppose we add two more strings, 'Computer Science' and 'cow', and get the resulting values from the hash functions: (8, 10, 14) and (0, 7, 9), respectively.
The filter would appear as such:

\begin{table}[h]
	\begin{center}
		\begin{tabular}{ | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | }
			\hline
			Bit		& 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 \\ \hline
			Value	& 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1  & 0  & 0  & 0  & 1  & 0  \\ \hline
		\end{tabular}
	\end{center}
\end{table}

As seen in the above scenario, there were some collisions, which is why one can never posit with 100\% accuracy that the data is a member of the set by testing the filter alone.
Even if 'Clemson ACM' had not been put through the filter, querying the filter for it would have still produced a positive, albeit false, answer.
Because of that fact, some additional checking is necessary to provide a definite answer when a query returns positive.
It is worth noting that as the filter begins to fill up, the number of false positives from queries increases.
A good number of hash functions, $k$, for a filter of $m$ bits and $n$ members is:

\Large
\begin{center}
	$k = \frac{m}{n}\ln 2$
\end{center}
\normalsize

The union and intersection operation is possible with Bloom filters. A union can be performed by OR-ing, and an intersection by AND-ing.
However, the filters \textit{must} have the same size \textbf{and} have used the same $k$ hash functions.

\subsection{Applications}

\begin{itemize}
	\item A Bloom filter with a low false positive rate has a significant advantage against a set.
	\item Reduce the number of times an expensive operation must be performed by providing a preliminary test for set membership.
\end{itemize}
