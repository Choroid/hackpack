\section{Segment Tree}
\index{segment tree}
\index{interval}

% #ifdef hackpackpp

It is often useful to be aware of the range properties of a given array, such as: prefix sums, suffix sums, range minimum queries, range maximum queries, etc.
For simpler problems, a secondary array may suffice to calculate a property like the prefix sum of an array.
The prefix sum calculation only takes $O(n)$ time to perform, and any query thereafter takes only $O(1)$ time.
But any updates to the source dataset will require $O(n)$ time to update the prefix sum calculations.
Frequent changes will quickly show the pitfall of this approach.
A segment tree is a data structure for storing information about intervals that can be constructed in $O(n \log(n))$ time.
Whenever the source data changes, update times stay low at $O(\log n)$ time.

% #endif

A segment tree is represented as an array of a size that is dependent on the dataset it is sourced from.
For a given array of size $n$, a segment tree constructed from it will use up to $2^{\lceil \log_2 (n)\rceil + 1} - 1$ space.
Once built, the structure of a segment tree cannot changed.

% #ifdef hackpack

\acmlisting[label=Segment Tree Reference Code, caption=Segment Tree Reference Code]{./structures/segment-tree/segment-tree.cpp}

% #endif


% #ifdef hackpackpp

Generally, a segment tree supports two operations: update and query.
The update operation will account for changes to values in the source dataset.
It is even possible to implement a range update operation to change an entire range of values.
The query operation allows for fast retrieval about segment information.
In the case of the prefix sum, the update operation will modify the tree's nodes such that it will contain correct information after changes, and the the query operation can return a sum for values in an arbitrary range.

\subsection{Applications}

\begin{itemize}
    \item range sums in a frequently changing dataset
    \item range minimum/maximum queries
\end{itemize}

\subsection{Example Contest Problem: Coming and Going}

In consideration of expanding the cows' barn, Farmer John decided to see just how many of his cows spent any given time of day in the barn.
To do so, he installed motion sensors on each entryway/exit to the building.
These sensors are able to detect both the entry and exit of a warm-blooded being.
This, coupled with his cows' tags, allows him to monitor the movements of specific cows.

The night after the full day in which the sensors were installed, Farmer John sat down to do what he thought was some straightforward analysis, but quickly realized that he was in over his head with only mental math.

Help him figure out which hours each day (he defines as 6AM to 8PM) the barn is the most popular place to be by giving him headcounts as he (slowly) tabulates the data.

\subsubsection{Input Format}

\begin{itemize}
    \item Line 1: A single integer, $C$, representing the number of cows Farmer John has data on.

    \item The following lines are placed in $C$ groups detailed as follows:
    \begin{itemize}
        \item A single line containing two integers, $t_1$ and $t_2$ representing a time range.
        These values are guaranteed to fall between 6 and 20 (inclusive), representing the times between and including 6AM to 8PM, except for the case when both are 0.
        If two cows are not present in the barn at the same time, but are in the same window, two cows should be counted.

        \item A single line containing a single integer, $k$, representing the number of time ranges to follow that a cow was present in the barn.

        \item $k$ lines with two distinct integers representing time ranges in which a cow was present in the barn.
        The first number is guaranteed to be strictly less than the second number.
    \end{itemize}
\end{itemize}

\acmlisting[label=Coming and Going Sample Input, caption=Coming and Going Sample Input]{./structures/segment-tree/problems/coming-and-going/coming-and-going.in}

\subsubsection{Output Format}

The only output should be the times and cow counts Farmer John requested in the order seen as given in the sample output below.
Times and cow counts should be printed only when $t_1$ and $t_2$ are not both zero in the sample input.

\acmlisting[label=Coming and Going Sample Output, caption=Coming and Going Sample Output]{./structures/segment-tree/problems/coming-and-going/coming-and-going.out}

\subsubsection{Sample Solution}

% #endif

\acmlisting[label=Coming and Going Sample Solution, caption=Coming and Going Sample Solution]{./structures/segment-tree/problems/coming-and-going/coming-and-going.cpp}

% #ifdef hackpackpp

\subsubsection{Lessons Learned}

\begin{itemize}
    \item The data the segment tree keeps track of can easily be changed with a few small modifications to the build, update, and query operations.
\end{itemize}

% #endif
