\section{Graph}
Graphs are useful for a variety of different real world problems.
Graphs are comprised of Nodes and Edges.
Nodes represent a distinct state.
Edges represent the possible transitions between states.
Graphs can be directed(edges are one way) or undirected(edges are the same going to or from a node).

Paths are graphs that have no branches off.
Cycles are graphs that connect back on them selves.
Trees are graphs that contain no cycles.
Forests are graphs that contain multiple disjoint trees.
Bipartite Graphs have a set of "source" nodes and a set of "edge" nodes

Two nodes $i,j$ are said to be connected if there is a path from i to j.
Two nodes $i,j$ are said to be strongly connected if there is a directed path from i to j and j to i.

\subsection{Reference}
\acmlisting[caption= Undirected Graph, label=Undirected Graph]{./structures/graph/graph.cpp}

\subsection{Applications}
For all run times, $N$ is the number of nodes, and $M$ is the number of edges.
\begin{itemize}
    \item Shortest Paths
        \begin{itemize}
            \item Breath First Search --- Graphs with equal weight edges $O(N+M)$
            \item Dijkstra's Algorithm --- Graphs with non-negative edges weights $O(N \log N)$.
            \item Bellman Ford --- Graphs with some negative edges $O(N^3)$
            \item Floyd Warshall --- Grahps with negative edges but not cycles $O(NM)$.
            \item Dynamic Programming --- Directed Acyclic Graphs
		\end{itemize}
	\item Minimum Spanning Trees 
		\begin{itemize}
			\item Prim's Algorithm --- for undirected graphs; if run for each component, finds the minimum spanning forest$O(M \log N)$.
			\item Kruskal's Algorithm --- for graphs; finds the minimum spanning forests in unconnected graphs $(M \log N)$
		\end{itemize}
	\item Similarity/Connectivity
		\begin{itemize}
			\item Depth First Search --- Find (Strongly) Connected Components $O(N+M)$
			\item Depth First Search --- Find a path from i to j $O(N+M)$
        \end{itemize}
    \item Topological Sorting 
        \begin{itemize}
            \item Depth First Search --- Use start and stop times to topologically sort $O(N+M)$
        \end{itemize}
    \item Matchings
    \item Flow/Routing
    \item Clustering
    \item Centrality
\end{itemize}

#ifdef hackpackpp
\subsection{Sample Contest Problem, The Cows Escape}
Farmer John's Farm has become infested with Zombies!
Farmer John being slightly out of shape wants to take the shortest amount of time to escape the zombies.

Farmer John's Farm is laid out in squares.
Being prepared, Farmer John has his Early Zombie Detection System that will alert him to the rating of the zombies in these squares.
Based off his research into the topic, Farmer John knows based on the rating how long it will take to evade the zombies in that sector.

Help Farmer John find the shortest time it will take Farmer John to escape his farm with his cows.

\subsubsection{Input Format}
\begin{itemize}
	\item Line 1:One integer $T$ indicating the number of test cases to evaluate
	\item Line 2:Three integers $k,w,h$ representing the number zombie classes to follow and the width and height of Farmer John's Farm
	\item Lines 3..$(3+k)$: The letter representing the zombie class, it will not be `F' and the time it will take to evade them, $t$
	\item Lines $(4+k)$..$(4+k+h)$: $W$ capital letters representing the zombie classes in each sector of farmer John's farm.  Farmer John's initial position is designated by `F'.
\end{itemize}

\subsubsection{Sample Input}
\acmlisting[caption=The Cows Escape Sample Input, label= The Cows Escape Sample Input]{./structures/graph/problems/escape/escape.in}

\subsubsection{Output Format}
\begin{itemize}
	\item Line 1:  1 integer per line for each test case representing the minimum time it takes to escape the farm.
\end{itemize}

\subsubsection{Sample Output}
\acmlisting[caption=The Cows Escape Sample Output, label= The Cows Escape Sample Output]{./structures/graph/problems/escape/escape.out}
\subsubsection{Sample Solution}
#endif

#ifdef hackpack
\subsection{Dijkstra in a graph}
#endif
\acmlisting[caption=The Cows Escape Sample Solution, label= The Cows Escape Sample Solution]{./structures/graph/problems/escape/escape.cpp}

#ifdef hackpackpp
\subsubsection{Lessons Learned}
\begin{itemize}
	\item Dijkstra can be solved using a priority queue using $O(N \log N)$ time.
\end{itemize}
#endif

