\documentclass[letterpaper, 10pt]{report}
\title{Clemson Hack Pack}
\author{Clemson ACM}
\date{\today}
\usepackage{multicol}
\usepackage{geometry}
\usepackage{tabularx}
\geometry{margin =1in}

%Set up the code verbatim sections
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\normalsize}

\begin{document}
\maketitle

\begingroup
\let\clearpage\relax
\chapter*{10 Commandments of ACM Contests}
\begin{center}Paraphrased from Dr. Dean\end{center}
\begin{multicols}{2}
\begin{enumerate}
    \item Thou shalt sort first and ask questions later
    \item Thou shalt know the STL and use it well
    \item Thou shalt know thy algorithms by heart
    \item Thou shalt brute force $\leq$ 10 million items
    \item Thou shalt when in doubt solve with DP
    \item Thou shalt never count by 1
    \item Thou shalt reinitialize thy data structures
    \item Thou shalt test often and submit early
    \item Thou shalt never trust a sample input
    \item Thou shalt print according to the output spec
\end{enumerate}
\end{multicols}
\begin{center}
Remember what the Dr. said\\
"Algorithms are Cool!"
\end{center}

\endgroup


\tableofcontents

\chapter{Basic Data Structures}
\section{Set}
Sets are Associative, Ordered, set, Unique Keyed, and Allocator Aware\cite{cplusplus}.  Set means that the key is also the value. Use it when it is only important if something has been seen before.
\begin{code}
    #include <set>
    std::set<type_one> myset;

    //iterator
    std::set<type_one>::iterator it;

    //insert O(N log(N)) or O(N) am for sorted inputs
    myset.insert(type_one (value));

    //remove O(log N) or O(1) am post-find
    myset.erase(it);
    myset.erase(key);

    //find O(log N)
    myset.find(key)
\end{code}
\section{Map}
Maps are Associative, Ordered, Mapped, Unique Keyed, and Allocator aware\cite{cplusplus}.  Mapped means that each key corresponds to a specific value. Use it to record relationships in data.
\begin{code}
    #include <map>
    std::map<key_type,value_type> mymap;

    //iterator
    std::map<key_type, value_type>::iterator it;

    //insert O(N log(N)) or O(N) am for sorted inputs
    mymap.insert( std::pair<key_type, value_type>(key, value);
    mymap[key] = value;

    //remove O(log N) or O(1) am post-find
    mymap.erase(it);
    mymap.erase(key);

    //find O(log N)
    mymap.find(key)
\end{code}
\section{Heaps}


\chapter{Algorithms}
\section{Dijkstra}

\chapter{C IO Functions}
Occasionally it is far easier to use the C IO functions to meet an output spec. It is also possible to set the precision and width options via numbers after the present,but before the specifier.  The general form of a specifier is: 

\begin{code}
    %[flags][width][.precision][length]specifier
\end{code}

\begin{table}[h]
    \caption{Format Specifier Codes \cite{cplusplus}}
    \begin{tabularx}{\textwidth}{|l|X|l|} \hline
        Format Code &   Output              &   Example     \\ \hline
        d           &   Signed Int          &   314         \\
        u           &   Unsigned Int        &   314         \\
        o           &   Unsigned Octal      &   472         \\
        x           &   Unsigned hex        &   13a         \\
        X           &   UNSIGNED HEX        &   13A         \\
        f           &   floating point      &   3.140000    \\
        e           &   Scientific notation &   3.140000e+00\\
        c           &   character           &   A           \\
        s           &   string              &   ACM         \\
        p           &   pointer address     &   0x40060c    \\
        l           &   Used with other specifiers to indicate a long & 314 \\
        \%\%        &   Prints a literal \% &   \%          \\
        \hline
    \end{tabularx}
\end{table}

\begin{table}[h]
    \caption{Modifier Flags \cite{cplusplus}}
    \begin{tabularx}{\textwidth}{|l|X|l|} \hline
        Format Code &   Output                  &   Example     \\ \hline
        -           &   Left-justify            &   314         \\
        +           &   Force-sign character    &   +314         \\
        \#           &   Show prefix             &   0x13a       \\
                    &   Show decimal point      &   314.        \\
        0           &   Left pad field with 0   &   0314       \\
        \hline
    \end{tabularx}
\end{table}

\section{Examples}
\begin{code}
    #include <stdio.h>
    int main (){
        //To stdout
        double f = 3.14;
        int    i = 314;
        char*  s = "ACM";
        printf("%5f,%5i,%5s\n", f, i, s);

        //Same thing to a file
        FILE * outputfile;
        outputfile = fopen("outputfile.txt","w");
        fprintf(outputfile,"%5f,%5i,%5s\n", f, i, s);
        fclose(outputfile);
    }
\end{code}

\chapter{Appendix}
\section{Some Basic VIMRC Settings}
\begin{multicols}{2}
\begin{code}
set mouse=a
imap jj $<ESC>$
set ai
set nu
set scs
set bs=2
set ts=4
sy on
colo=slate
set bg=dark
\end{code}
\end{multicols}

\section{Makefile}
\begin{code}
CC=g++
all :
    $(CC) *.c -o $*.o
\end{code}

\bibliographystyle{plain}
\bibliography{acmhints}

\end{document}

