#!/usr/bin/env python3
import argparse
import collections
import functools
import gzip
import os.path
import re

parser = argparse.ArgumentParser(description='trim and convert C++ man pages (generated by \'cppman\') to a TeX file')
parser.add_argument('-m', '--man-path', default='~/.local/share/man/cppreference.com', type=str, dest='man_path', help='directory containing gzipped man (3) pages')
parser.add_argument('tex_out', help='path to put the generated TeX file')

args = parser.parse_args()

#Path to man pages with .3.gz ending (probably downloaded with 'cppman -c')
man_path = os.path.expanduser(args.man_path)

#TeX output file
tex_file = args.tex_out

#Pages to include by man page name
manpages = collections.OrderedDict((
		('Utilities library', (
			#Classes
			'std::pair',
			'std::tuple',
		)),
		('Strings library', (
			#Classes
			'std::basic_string',
		)),
		('Containers library', (
			#Classes
			'std::array',
			'std::vector',
			'std::deque',
			'std::forward_list',
			'std::list',
			'std::set',
			'std::map',
			'std::multiset',
			'std::multimap',
			'std::unordered_set',
			'std::unordered_map',
			'std::unordered_multiset',
			'std::unordered_multimap',
			'std::stack',
			'std::queue',
			'std::priority_queue',
		)),
		('Algorithms library', (
			#Functions
			# Non-modifying sequence operations
			'std::all_of',
			'std::for_each',
			'std::count',
			'std::mismatch',
			'std::equal',
			'std::find',
			'std::find_end', #
			'std::find_first_of', #
			'std::adjacent_find',
			'std::search',
			'std::search_n', #
			# Modifying sequence operations
			'std::copy',
			'std::copy_n', #
			'std::copy_backward', #
			'std::move', #
			'std::move_backward', #
			'std::fill',
			'std::fill_n', #
			'std::transform',
			'std::generate',
			'std::generate_n', #
			'std::remove',
			'std::remove_copy', #
			'std::replace',
			'std::replace_copy', #
			'std::swap',
			'std::swap_ranges',
			'std::iter_swap', #
			'std::reverse',
			'std::reverse_copy',
			'std::rotate',
			'std::rotate_copy',
			'std::random_shuffle',
			'std::unique',
			'std::unique_copy', #
			# Partitioning operations
			'std::partition',
			'std::partition_copy', #
			'std::stable_partition',
			# Sorting operations
			'std::is_sorted',
			'std::sort',
			'std::partial_sort', #
			'std::partial_sort_copy', #
			'std::stable_sort',
			'std::nth_element',
			# Binary search operations (on sorted ranges)
			'std::lower_bound',
			'std::upper_bound',
			'std::binary_search',
			'std::equal_range', #
			# Set operations (on sorted ranges)
			'std::merge',
			'std::inplace_merge',
			'std::includes', #
			'std::set_difference', #
			'std::set_intersection', #
			'std::set_symmetric_difference', #
			'std::set_union', #
			# Heap operations
			'std::is_heap',
			'std::make_heap',
			'std::push_heap',
			'std::pop_heap',
			'std::sort_heap',
			# Minimum/maximum operations
			'std::max',
			'std::max_element',
			'std::min',
			'std::min_element',
			'std::minmax', #
			'std::minmax_element', #
			'std::lexicographical_compare', #
			'std::is_permutation', #
			'std::next_permutation',
			'std::prev_permutation',
		)),
		('Numerics library', (
			#Functions
			'std::iota',
			'std::accumulate',
			'std::inner_product', #
			'std::adjacent_difference',
			'std::partial_sum', #
		)),
		('Input/output library', (
			#Special
			# Format flags
			'std::dec',
			'std::fixed',
			'std::boolalpha', #
		)),
))

#Section headings to include in trimmed down man page
sections = [
	#Common
	'NAME',
	'SYNOPSIS',
	#Classes
	'MEMBER FUNCTIONS',
	'NON-MEMBER FUNCTIONS',
	#Functions/Methods
	'PARAMETERS',
	'RETURN VALUE',
]

#Creepy regex magic
regex_flags = re.MULTILINE|re.DOTALL

trim_regexes = [
	re.compile(r'^\.TH .*?$\n', regex_flags),
]
trim_regexes.extend([re.compile(r'^\.SH "' + section + r'"$.*?(?=\.SH )', regex_flags) for section in sections])

#Generator to get each part of man_contents that we want
def man_trim_gen(man_contents):
	for regex in trim_regexes:
		match = regex.search(man_contents)
		if match:
			yield match.group()

#I'll be honest - we're throwing science at the wall here to see what sticks. No idea what it'll do. Probably nothing. Best-case scenario, you might get some superpowers. Worst case, some tumors, which we'll cut out.
tex_repl_regexes = [
	(re.compile(r'^\.TH "([^"]+)" .*?$', regex_flags), r'\\subsection{\1}'),
	(re.compile(r'^\.SH "([^"]+)"$', regex_flags), r'\\subsubsection{\1}'),
	(re.compile(r'^\.sp(.*?)$', regex_flags), r'\1'),
	(re.compile(r'^\.nf\n(.*?)\n\.fi$', regex_flags), r'\\begin{lstlisting}\n\1\n\\end{lstlisting}'),
	(re.compile(r'^\.IP "(.*?)"\n(.*?)$', regex_flags), r'\1 - \2'),
	(re.compile(r'^\.SS "([^"]+)"$', regex_flags), r'\\paragraph{\1}'),
	(re.compile(r'^#', regex_flags), r'\\#'),
	(re.compile(r'\$', regex_flags), r'\\$'),
	(re.compile(r'_', regex_flags), r'\\_'),
	(re.compile(r'&', regex_flags), r'\\&'),
]

tex_section = r'\section{\1}'

def man_to_tex(man_contents):
	tex_contents = man_contents
	for regex, repl in tex_repl_regexes:
		tex_contents = regex.sub(repl, tex_contents)

	return tex_contents

with open(tex_file, 'w') as tex_out:
	for section, pages in manpages.items():
		tex_out.write(tex_section.replace(r'\1', section) + '\n\n')

		for page in pages:
			man_file = man_path + '/' + page + '.3.gz'

			#Open the man page
			with gzip.open(man_file, 'r') as man_in:
				man_contents = man_in.read().decode()

			#Make a trimmed version
			man_trimmed = '\n'.join(man_trim_gen(man_contents))

			#Convert to TeX
			tex_contents = man_to_tex(man_trimmed)

			#Write the TeX out
			tex_out.write(tex_contents + '\n\n')
